# 1. 问题背景

1. RabbitMQ现在已经在COS大范围使用，但是有些应用使用的方式并不是最优。
2. 通过此文档总结一些最佳实践，供大家参考，写出更高效，更健壮的应用。

# 2. 最佳实践

## 2.1. MQ客户端

### 2.1.1. 消息发送和接收建立不同的连接

1. 发送消息如果阻塞的话会影响消费消息的速度，形成恶性循环，所以建议配置两个物理连接分别用来发送和消费消息。

### 2.1.2. 客户端实现连接失败重连

1. 当意外网络失败时或mq server重启时，客户端可以自动重连恢复服务。

### 2.1.3. 建立消息服务防腐层，方便迁移升级

1. 每个应用建议开发一个发送消息的封装类，方便mq的迁移与升级

 

## 2.2. 消息消费者

### 2.2.1. 消费者配置并发消费者个数

1. 如果消费者对消息的时序不是特别敏感，建议配置合适的并发消费者，增加消费能力，防止只有一个消费者阻塞时造成消息积压。

### 2.2.2. 消费者配置每次读取消费个数

1. 跟上面的场景类似，配置prefetchCount，决定每次读取消息时，获取消息的个数，可以减少网络的传输次数，提高消费能力，但是会降低消息的时序性。

### 2.2.3. 消费者消费消息时不抛出异常

1. 如果消费消息时抛出异常，则消息无法正常的ack，会重新放回队列，重新发送此消息，如果还无法消费，会一直重发，相当于死循环状态，影响后续的消息处理和整个MQ server的性能。

### 2.2.4. 评估消费能力

1. 有一个基本原则是消费能力应该大于生产能力，否则就会造成消息的积压
2. MQ允许少量的消息积压，消息积压会降低MQserver的性能
3. 大量的消费积压会触发报警，而且大量积压会触发内存流控，影响整个集群

### 2.2.5. 等幂性和无序性

•Message1

–{[dealId:123](http://dealid:123/)}

•Message2

–{[dealId:123,oldValue:12,newValue:13](http://dealid:123%2Coldvalue:12%2Cnewvalue:13/)}

•推荐Message1的形式

–优点：等幂、无序、简单

–缺点：可能消息过快，本地DB事务还没提交

–解决方案：MQ发送尽量靠后

## 2.3. 消息生产者

### 2.3.1. 生产者实现消息发送失败重发

1. 应用系统发送时，建议如果出错的话可以存储到本地数据库或文件系统，然后实现定时重发或手动重发。

 

### 2.3.2. 发生流控时快速失败

1. 新版的mq client已经实现了此功能，当出现流控时，实现快速失败，减小mq故障的影响面积。

 

## 2.4. MQ服务器端



https://km.sankuai.com/page/28280761