# MVCC

一般我们认为MVCC有下面几个特点：

- 每行数据都存在一个版本，每次数据更新时都更新该版本；
- 修改时Copy出当前版本随意修改，各个事务之间无干扰；
- 保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）。

就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道，而Innodb的实现方式是：

- 事务以排他锁的形式修改原始数据；
- 把修改前的数据存放于undo log，通过回滚指针与主数据关联；
- 修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）。

# 乐观锁与悲观锁

## 一、乐观锁

总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。

**version方式**：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加1。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

```mysql
update table set x=x+1, version=version+1 where id=#{id} and version=#{version};  
```



**CAS操作方式：**即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。

## 二、悲观锁

 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。



# 两段锁

## 一、何为两段锁

在一个事务操作中，分为**加锁阶段**和**解锁阶段**，且所有的加锁操作在解锁操作之前。

## 二、何时加锁

当对记录进行更新操作或者**select for update(X锁)、lock in share mode(S锁)**时，会对记录进行加锁，锁的种类很多，不在此赘述。

## 三、何时解锁

在一个事务中，只有在**commit**或者**rollback**时，才是解锁阶段。